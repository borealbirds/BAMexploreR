##################################################################################
#' Estimate a presence/absence threshold using a Lorenz curve
#'
#' @description This function fits a Lorenz curve to a raster's density
#' values using \code{opticut::lorenz()}.
#' The Lorenz curve is not plotted. See package \code{opticut} for
#' inspecting Lorenz curves. Instead, the plot generated by \code{plot=TRUE} is the user's
#' input density raster re-coded to presence (1) / absence (0) values.
#'
#'
#' @param raster A raster of the "Area of Interest". Defined and created via Melina's function(s).
#'
#' @param quantile Default is \code{"by_lorenz"}, and the  optimum threshold is estimated via
#' \code{opticut::lorenz()} as the pixel density when the slope of the tangent of the Lorenz function is 1.
#' If a custom threshold is preferred, set this argument using a \code{numeric} between 0 and 1.
#' Indicates a cumulative proportion of pixels, above which all raster pixel values are assigned as "presence".
#' Raster pixel values below the quantile are assigned "absent". E.g. By setting \code{quantile=0.8},
#' the threshold density for separating presence versus absence is whatever pixel value accumulates 80% of the total
#' pixels from the raster.
#'
#' @param plot Default is \code{TRUE} for visualizing occurrence patterns.
#'
#' @return A list with:
#' \describe{
#'   \item{raster}{A \code{SpatRaster} with binary presence (1) / absence (0) values.}
#'   \item{threshold}{A \code{numeric} value: the estimated density threshold.}
#'   \item{population_summary}{A \code{data.frame} with estimated total population size,
#'   mean, and standard deviation, before and after thresholding.
#'   See: \code{BAMexploreR::pop_sizeNM()}}
#' }
#'
#' @details \code{opticut::lorenz()} generates a Lorenz plot where the x-axis represents the cumulative
#' proportion of area (sorted by bird density, \code{p}) and the y-axis represents the cumulative
#' proportion of the raster's total population (\code{L}). If bird density were uniform across
#' space, the plot would follow a line with a slope of 1. In reality birds are not distributed evenly
#' on the landscape. \code{lorenz()} estimates a pixel density threshold separating "presence" from "absence".
#' The threshold is defined as the point on the Lorenz curve where the tangent has a slope of 1 and \code{p - L}
#' is maximized. See \code{?opticut::lorenz} for details.
#' Note that in some cases, the Lorenz-derived threshold is similar to the mean density, however, they
#' estimate different ecological quantities and are not inherently equal.
#'
#'
#'
#'
#' @importFrom opticut lorenz iquantile
#' @importFrom terra rast values setValues
#' @importFrom dplyr arrange bind_rows
#' @importFrom purrr map imap map_dbl
#'
#' @export
#' @examples
#'
#' # download rasters for Tennessee Warbler and Ovenbird
#' rasters <- getlayerNM(c("TEWA", "OVEN"), "v4", destfile=tempdir())
#'
#' # visualize core habitat
#' occurrenceNM(rasters)

occurrenceNM <- function(raster_list, quantile="by_lorenz", plot=TRUE){

  # check for valid input
  stopifnot(is.list(raster_list))
  stopifnot(all(purrr::map_lgl(raster_list, ~ inherits(.x, "SpatRaster"))))

  # define thresholding function for a single raster
  threshold_estimate <- function(raster_i, spp){

    # retrieve density per pixel, retain this vector with NAs to preserve pixel positions
    dpp <- terra::values(raster_i, na.rm=FALSE)

    # remove NAs for `lorenz()`
    dpp_no_nas <- dpp[!is.na(dpp)]

    # estimate threshold from a Lorenz curve
    lorenz_fit <- opticut::lorenz(dpp_no_nas)

      if (quantile == "by_lorenz"){

        # locate the pixel value where the tangent approaches 1:1
        t_pixel <- summary(lorenz_fit)["t"]

        # "x" is the bird density when "t" approaches 1:1
        # ("p" is the proportion of pixels, "L" is the proportion of birds)
        optimum_threshold <- lorenz_fit[t_pixel, "x"]
        names(optimum_threshold) <- "optimum threshold"

      } else {

        # `L` for ordered cumulative abundance quantiles (versus non-cumulative)
        # `threshold` partitions "1-threshold" proportion of values as presence (1) and the rest ("threshold") as absence (0)
        # e.g. for `threshold=0.8` the densest 20% of values are assigned as presence (1) and the rest as absence (0)
        optimum_threshold <- iquantile(lorenz_fit, probs = quantile, type = "L")
        names(optimum_threshold) <- "optimum threshold"

    } # finish finding optimum threshold

    # create binarized density raster based on the current threshold
    # note: need to preserve NA positions from the original raster to
    # maintain raster range between input and output
    classify_pixels <- function(dpp, threshold) {
      ifelse(dpp >= threshold, 1, ifelse(!is.na(dpp), 0, NA))
    }

    pixels_binary <- classify_pixels(dpp, optimum_threshold)

    # write the binary values into a raster object
    binary_raster <- terra::setValues(raster_i, pixels_binary)

    # mask the original raster with above threshold values
    threshold_raster <- terra::setValues(raster_i, ifelse(dpp >= optimum_threshold, dpp, 0))

    # plot occurrence map
    if (plot==TRUE){
      terra::plot(binary_raster, main=paste("density threshold =", round(optimum_threshold, digits = 5)))
    }

    return(list(occurrence_raster = binary_raster,
                threshold_raster = threshold_raster,
                threshold = optimum_threshold))

  } # close thresholding function


  # apply threshold estimate to user's list of rasters
  output_list <- purrr::imap(raster_list, threshold_estimate)

  # extract output rasters for population estimatation
  occurrence_rasters <- purrr::map(output_list, "occurrence_raster")
  threshold_rasters <- purrr::map(output_list, "threshold_raster")
  thresholds <- purrr::map_dbl(output_list, "threshold")

  # estimate population size
  og_pop_size <- BAMexploreR::pop_sizeNM(raster_list) |> mutate(type = "no_threshold")
  threshold_pop_size <- BAMexploreR::pop_sizeNM(threshold_rasters) |> mutate(type = "with_threshold")

  pop_summary <-
    bind_rows(og_pop_size, threshold_pop_size) |>
    arrange(spp)

  return(list(
    occurrence_rasters = occurrence_rasters,
    population_summary = pop_summary))

}

