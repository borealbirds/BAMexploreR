##################################################################################
#' Estimate a presence/absence threshold using a Lorenz curve
#'
#' @description This function fits a Lorenz curve to a raster's density
#' values using \code{opticut::lorenz()}.
#' The Lorenz curve is not plotted. See package \code{opticut} for
#' inspecting Lorenz curves. Instead, the plot generated by \code{plot=TRUE} is the user's
#' input density raster re-coded to presence (1) / absence (0) values.
#'
#'
#' @param raster_list A raster of the "Area of Interest". Defined and created via Melina's function(s).
#'
#' @param quantile Default is \code{"by_lorenz"}, and the  optimum threshold is estimated via
#' \code{opticut::lorenz()} as the pixel density when the slope of the tangent of the Lorenz function is 1.
#' If a custom threshold is preferred, set this argument using a \code{numeric} between 0 and 1.
#' This value indicates a cumulative proportion of pixels, above which all raster pixel values are assigned as "presence".
#' Raster pixel values below the quantile are assigned "absent". E.g. By setting \code{quantile=0.8},
#' the threshold density for separating presence versus absence is whatever pixel value accumulates 80% of the total
#' pixels from the raster.
#'
#' @param plot Default is \code{TRUE} for visualizing occurrence patterns.
#'
#' @return A list with:
#' \describe{
#'   \item{raster}{A \code{SpatRaster} with binary presence (1) / absence (0) values.}
#'   \item{occurrence_summary}{A \code{data.frame} with estimated area of occupancy
#'   in kmÂ², before and after thresholding.}
#'   }
#'
#' @details \code{opticut::lorenz()} generates a Lorenz plot where the x-axis represents the cumulative
#' proportion of area (sorted by bird density, \code{p}) and the y-axis represents the cumulative
#' proportion of the raster's total population (\code{L}). If bird density were uniform across
#' space, the plot would follow a line with a slope of 1. In reality birds are not distributed evenly
#' on the landscape. \code{lorenz()} estimates a pixel density threshold separating "presence" from "absence".
#' The threshold is defined as the point on the Lorenz curve where the tangent has a slope of 1 and \code{p - L}
#' is maximized. See \code{?opticut::lorenz} for details.
#' Note that in some cases, the Lorenz-derived threshold is similar to the mean density, however, they
#' estimate different ecological quantities and are not inherently equal.
#'
#'
#'
#'
#' @importFrom opticut lorenz iquantile
#' @importFrom terra rast values setValues
#' @importFrom dplyr arrange bind_rows
#' @importFrom purrr map imap map_dbl
#' @importFrom tibble tibble
#' @export
#' @examples
#'
#' # download v4 rasters for Tennessee Warbler and Ovenbird
#' rasters <- bam_get_layer(c("TEWA", "OVEN"), "v4", destfile=tempdir())
#'
#' # visualize core habitat
#' bam_occurrence(rasters)
#'
#' # set custom threshold and compare core habitat
#' bam_occurrence(rasters, quantile=0.8)
#'
#' # analyse core habitat in a custom area, using v5 predictions for Tennessee Warbler
#' aoi_sf <- vect(system.file("extdata", "vignette_poly_5072.shp", package = "BAMexploreR"))
#' rasterv5 <- bam_get_layer("TEWA", "v5",  crop_ext = aoi_sf, destfile = tempdir(), year = "2020")
#' bam_occurrence(rasterv5)
#'
#'

bam_occurrence <- function(raster_list, quantile="by_lorenz", plot=TRUE){

  # check for valid input
  stopifnot(is.list(raster_list))
  stopifnot(all(purrr::map_lgl(raster_list, ~ inherits(.x, "SpatRaster"))))

  # extract the mean if the SpatRaster has a "mean" layer
  extract_mean_layer <- function(raster_i){

    if ("mean" %in% names(raster_i)){

       return(raster_i[["mean"]])

    } else return(raster_i)
  }

  raster_list <- lapply(raster_list, extract_mean_layer)


  # define thresholding function for a single raster
  estimate_threshold <- function(raster_i, spp){

    # retrieve density per pixel, retain this vector with NAs to preserve pixel positions
    dpp <- terra::values(raster_i, na.rm=FALSE)

    # remove NAs for `lorenz()`
    dpp_no_nas <- dpp[!is.na(dpp)]

    # estimate threshold from a Lorenz curve
    lorenz_fit <- opticut::lorenz(dpp_no_nas)

    # apply threshold
    if (quantile == "by_lorenz"){

      # locate the pixel value where the tangent approaches 1:1
      t_pixel <- summary(lorenz_fit)["t"]

      # "x" is bird density when "t_pixel" approaches 1:1
      # ("p" is the proportion of pixels, "L" is the proportion of birds)
      optimum_threshold <- lorenz_fit[t_pixel, "x"]
      names(optimum_threshold) <- "optimum threshold"

    } else {

      # `L` for ordered cumulative abundance quantiles (versus non-cumulative)
      # `threshold` partitions "1 minus threshold" proportion of values as presence (1) and the rest ("threshold") as absence (0)
      # e.g. for `threshold=0.8` the densest 20% of values are assigned as presence (1) and the rest as absence (0)
      optimum_threshold <- quantile(lorenz_fit, probs = quantile, type = "L")
      names(optimum_threshold) <- "optimum threshold"

   } # finish finding optimum threshold

    # create binarized density raster based on the current threshold
    # note: need to preserve NA positions from the original raster to
    # maintain raster range between input and output
    classify_pixels <- function(dpp, threshold) {
      ifelse(dpp >= threshold, 1, ifelse(!is.na(dpp), 0, NA))
    }

    pixels_binary <- classify_pixels(dpp, optimum_threshold)

    # write the binary values into a raster object
    binary_raster <- terra::setValues(raster_i, pixels_binary)

    # mask the original raster with above threshold values
    threshold_raster <- terra::setValues(raster_i, ifelse(dpp >= optimum_threshold, dpp, 0))

    # count occurrence pixels before and after thresholding
    n_pixels <- terra::global(raster_i >= 0, "sum", na.rm = TRUE)[1,1]
    n_core_pixels <- terra::global(binary_raster == 1, "sum", na.rm = TRUE)[1,1]

    # get pixel area in square kilometers
    pixel_area_km2 <- (terra::res(raster_i)[1] * terra::res(raster_i)[2]) / 1e6  # convert square meters to square km

    # total area of core habitat in km2
    og_area_km2 <- n_pixels * pixel_area_km2
    core_area_km2 <- n_core_pixels * pixel_area_km2


    # plot occurrence map
    if (plot==TRUE){
      terra::plot(binary_raster, main=paste("density threshold =", round(optimum_threshold, digits = 4), paste("\n", spp)))
    }

    return(list(occurrence_raster = binary_raster,
                threshold_raster = threshold_raster,
                threshold = optimum_threshold,
                og_area_km2 = og_area_km2,
                core_area_km2 = core_area_km2))

  } # close thresholding function


  # apply threshold estimate to user's list of rasters
  output_list <- purrr::imap(raster_list, estimate_threshold)

  # extract other area data from list output
  thresholds <- purrr::map_dbl(output_list, "threshold")
  og_area <- tibble::tibble(species = names(output_list), type="no_threshold", area_km2=purrr::map_dbl(output_list, "og_area_km2"))
  threshold_area <- tibble::tibble(species = names(output_list), type="with_threshold", area_km2=purrr::map_dbl(output_list, "core_area_km2"))

  occurrence_summary <-
    bind_rows(og_area, threshold_area) |>
    arrange(species)

  return(list(
    occurrence_rasters = purrr::map(output_list, "occurrence_raster"),
    occurrence_summary = occurrence_summary))

}

